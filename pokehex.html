<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PokéHex</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a2e;
            background-image: linear-gradient(180deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #e0e0e0;
        }
        .app-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        }
        .mode-toggle button {
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
        }
        .mode-toggle button.active {
            color: #fff;
            border-bottom-color: #fca311;
        }
        .search-container {
            position: relative;
        }
        .search-input {
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }
        .search-input:focus {
            background: rgba(0, 0, 0, 0.3);
            border-color: #fca311;
            box-shadow: 0 0 15px rgba(252, 163, 17, 0.3);
        }
        .search-button {
            background: linear-gradient(45deg, #fca311, #e75a7c);
            transition: all 0.3s ease;
        }
        .search-button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(252, 163, 17, 0.5);
        }
        .suggestions-list {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: #16213e;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 0 0 15px 15px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 10;
        }
        .suggestion-item {
            padding: 10px 20px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .suggestion-item:hover {
            background-color: rgba(252, 163, 17, 0.2);
        }
        .type-badge {
            display: inline-block;
            padding: 0.3rem 1rem;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: bold;
            text-transform: uppercase;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.4);
            border: 1px solid rgba(255,255,255,0.2);
            transition: all 0.2s ease;
        }
        .type-badge.selectable {
             cursor: pointer;
        }
        .type-badge.selectable:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        .type-badge.selected {
            box-shadow: 0 0 15px, inset 0 0 5px;
            transform: scale(1.05);
        }
        .evolution-pokemon {
            cursor: pointer;
        }
        .type-normal { background-color: #A8A77A; box-shadow: 0 0 15px #A8A77A80; }
        .type-fire { background-color: #EE8130; box-shadow: 0 0 15px #EE813080; }
        .type-water { background-color: #6390F0; box-shadow: 0 0 15px #6390F080; }
        .type-electric { background-color: #F7D02C; color: #212121; box-shadow: 0 0 15px #F7D02C80; }
        .type-grass { background-color: #7AC74C; box-shadow: 0 0 15px #7AC74C80; }
        .type-ice { background-color: #96D9D6; color: #212121; box-shadow: 0 0 15px #96D9D680; }
        .type-fighting { background-color: #C22E28; box-shadow: 0 0 15px #C22E2880; }
        .type-poison { background-color: #A33EA1; box-shadow: 0 0 15px #A33EA180; }
        .type-ground { background-color: #E2BF65; color: #212121; box-shadow: 0 0 15px #E2BF6580; }
        .type-flying { background-color: #A98FF3; box-shadow: 0 0 15px #A98FF380; }
        .type-psychic { background-color: #F95587; box-shadow: 0 0 15px #F9558780; }
        .type-bug { background-color: #A6B91A; box-shadow: 0 0 15px #A6B91A80; }
        .type-rock { background-color: #B6A136; box-shadow: 0 0 15px #B6A13680; }
        .type-ghost { background-color: #735797; box-shadow: 0 0 15px #73579780; }
        .type-dragon { background-color: #6F35FC; box-shadow: 0 0 15px #6F35FC80; }
        .type-dark { background-color: #705746; box-shadow: 0 0 15px #70574680; }
        .type-steel { background-color: #B7B7CE; box-shadow: 0 0 15px #B7B7CE80; }
        .type-fairy { background-color: #D685AD; box-shadow: 0 0 15px #D685AD80; }
    </style>
</head>
<body>

    <div class="container mx-auto p-4 sm:p-6 lg:p-8 max-w-4xl">
        <header class="text-center mb-6">
            <h1 class="text-4xl sm:text-5xl font-black tracking-tighter text-white" style="text-shadow: 0 0 10px #fca311, 0 0 20px #e75a7c;">PokéHex</h1>
        </header>

        <div class="app-container p-4 sm:p-8">
            <div class="mode-toggle flex justify-center gap-8 mb-6 border-b border-gray-700">
                <button id="mode-pokedex" class="text-xl font-bold pb-2 active">Pokédex</button>
                <button id="mode-typechart" class="text-xl font-bold pb-2">Type Chart</button>
            </div>

            <!-- Pokedex Search View -->
            <div id="pokedex-view">
                <div class="flex flex-col sm:flex-row items-center justify-center gap-4 mb-6">
                    <div class="w-full sm:w-2/3 search-container">
                        <input type="text" id="pokemon-search" class="w-full px-6 py-3 text-lg focus:outline-none rounded-full search-input" placeholder="Enter Pokémon name or ID...">
                        <div id="suggestions-container" class="suggestions-list hidden"></div>
                    </div>
                    <button id="search-button" class="w-full sm:w-auto px-8 py-3 font-bold text-white rounded-full search-button">Search</button>
                </div>
                <div id="pokedex-display" class="min-h-[400px] flex items-center justify-center">
                    <p class="text-gray-400 text-center text-lg">Search for a Pokémon to see its entry.</p>
                </div>
            </div>

            <!-- Type Chart View -->
            <div id="type-chart-view" class="hidden">
                 <div class="text-center mb-4">
                    <h2 class="text-2xl font-bold">Type Effectiveness Calculator</h2>
                    <p class="text-gray-400">Select one or two types to see their defensive matchups.</p>
                </div>
                <div id="type-selection-grid" class="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-6 gap-3 mb-6">
                    <!-- Type buttons will be generated here -->
                </div>
                <div id="type-results-display" class="min-h-[200px]"></div>
            </div>
        </div>
    </div>

    <script>
        // DOM Elements
        const modePokedexBtn = document.getElementById('mode-pokedex');
        const modeTypeChartBtn = document.getElementById('mode-typechart');
        const pokedexView = document.getElementById('pokedex-view');
        const typeChartView = document.getElementById('type-chart-view');
        const searchInput = document.getElementById('pokemon-search');
        const searchButton = document.getElementById('search-button');
        const pokedexDisplay = document.getElementById('pokedex-display');
        const suggestionsContainer = document.getElementById('suggestions-container');
        const typeSelectionGrid = document.getElementById('type-selection-grid');
        const typeResultsDisplay = document.getElementById('type-results-display');

        // App State
        let currentMode = 'pokedex';
        let selectedTypes = [];
        const allPokemonTypes = ['normal', 'fire', 'water', 'electric', 'grass', 'ice', 'fighting', 'poison', 'ground', 'flying', 'psychic', 'bug', 'rock', 'ghost', 'dragon', 'dark', 'steel', 'fairy'];
        const typeRelationsCache = {};
        let allPokemonNames = [];

        const versionDetails = {
            'red': { series: 'Red/Blue', console: 'Game Boy' }, 'blue': { series: 'Red/Blue', console: 'Game Boy' },
            'yellow': { series: 'Yellow', console: 'Game Boy' },
            'gold': { series: 'Gold/Silver', console: 'Game Boy Color' }, 'silver': { series: 'Gold/Silver', console: 'Game Boy Color' },
            'crystal': { series: 'Crystal', console: 'Game Boy Color' },
            'ruby': { series: 'Ruby/Sapphire', console: 'Game Boy Advance' }, 'sapphire': { series: 'Ruby/Sapphire', console: 'Game Boy Advance' },
            'emerald': { series: 'Emerald', console: 'Game Boy Advance' },
            'firered': { series: 'FireRed/LeafGreen', console: 'Game Boy Advance' }, 'leafgreen': { series: 'FireRed/LeafGreen', console: 'Game Boy Advance' },
            'diamond': { series: 'Diamond/Pearl', console: 'Nintendo DS' }, 'pearl': { series: 'Diamond/Pearl', console: 'Nintendo DS' },
            'platinum': { series: 'Platinum', console: 'Nintendo DS' },
            'heartgold': { series: 'HeartGold/SoulSilver', console: 'Nintendo DS' }, 'soulsilver': { series: 'HeartGold/SoulSilver', console: 'Nintendo DS' },
            'black': { series: 'Black/White', console: 'Nintendo DS' }, 'white': { series: 'Black/White', console: 'Nintendo DS' },
            'black-2': { series: 'Black 2/White 2', console: 'Nintendo DS' }, 'white-2': { series: 'Black 2/White 2', console: 'Nintendo DS' },
            'x': { series: 'X/Y', console: 'Nintendo 3DS' }, 'y': { series: 'X/Y', console: 'Nintendo 3DS' },
            'omega-ruby': { series: 'Omega Ruby/Alpha Sapphire', console: 'Nintendo 3DS' }, 'alpha-sapphire': { series: 'Omega Ruby/Alpha Sapphire', console: 'Nintendo 3DS' },
            'sun': { series: 'Sun/Moon', console: 'Nintendo 3DS' }, 'moon': { series: 'Sun/Moon', console: 'Nintendo 3DS' },
            'ultra-sun': { series: 'Ultra Sun/Ultra Moon', console: 'Nintendo 3DS' }, 'ultra-moon': { series: 'Ultra Sun/Ultra Moon', console: 'Nintendo 3DS' },
            'sword': { series: 'Sword/Shield (+DLC)', console: 'Nintendo Switch' }, 'shield': { series: 'Sword/Shield (+DLC)', console: 'Nintendo Switch' },
            'brilliant-diamond': { series: 'Brilliant Diamond/Shining Pearl', console: 'Nintendo Switch' }, 'shining-pearl': { series: 'Brilliant Diamond/Shining Pearl', console: 'Nintendo Switch' },
            'legends-arceus': { series: 'Legends: Arceus', console: 'Nintendo Switch' },
            'scarlet': { series: 'Scarlet/Violet (+DLC)', console: 'Nintendo Switch' }, 'violet': { series: 'Scarlet/Violet (+DLC)', console: 'Nintendo Switch' },
        };

        // --- DATA FETCHING & CACHING ---
        const fetchAllPokemonNames = async () => {
            try {
                const response = await fetch('https://pokeapi.co/api/v2/pokemon?limit=1302');
                const data = await response.json();
                allPokemonNames = data.results.map(p => p.name);
            } catch (error) {
                console.error("Failed to fetch Pokémon list:", error);
            }
        };

        const getPokemonData = async (pokemon) => {
            try {
                const response = await fetch(`https://pokeapi.co/api/v2/pokemon/${pokemon.toString().toLowerCase()}`);
                if (!response.ok) throw new Error('Pokémon not found!');
                return await response.json();
            } catch (error) {
                displayError(error.message);
                return null;
            }
        };

        const getEvolutionChain = async (speciesUrl) => {
            try {
                const speciesResponse = await fetch(speciesUrl);
                const speciesData = await speciesResponse.json();
                const evolutionResponse = await fetch(speciesData.evolution_chain.url);
                return await evolutionResponse.json();
            } catch (error) {
                console.error("Error fetching evolution chain:", error);
                return null;
            }
        };
        
        const getTypeData = async (typeName) => {
            if (typeRelationsCache[typeName]) return typeRelationsCache[typeName];
            try {
                const response = await fetch(`https://pokeapi.co/api/v2/type/${typeName}`);
                const data = await response.json();
                typeRelationsCache[typeName] = data.damage_relations;
                return data.damage_relations;
            } catch (error) {
                console.error(`Failed to fetch type data for ${typeName}`, error);
                return null;
            }
        };

        // --- POKEDEX DISPLAY FUNCTIONS ---
        const formatEvolutionDetails = (details) => {
            if (!details) return '';
            const trigger = details.trigger.name.replace(/-/g, ' ');
            let conditionParts = [];

            if (details.min_level) conditionParts.push(`Lvl ${details.min_level}`);
            if (details.min_happiness) conditionParts.push(`High Friendship`);
            if (details.min_affection) conditionParts.push(`High Affection`);
            if (details.gender === 1) conditionParts.push(`Female`);
            if (details.gender === 2) conditionParts.push(`Male`);
            if (details.item) conditionParts.push(`Use ${details.item.name.replace(/-/g, ' ')}`);
            if (details.held_item) conditionParts.push(`Hold ${details.held_item.name.replace(/-/g, ' ')}`);
            if (details.known_move) conditionParts.push(`Knows ${details.known_move.name.replace(/-/g, ' ')}`);
            if (details.time_of_day) conditionParts.push(`at ${details.time_of_day}time`);
            if (details.location) conditionParts.push(`at ${details.location.name.replace(/-/g, ' ')}`);
            if (details.needs_overworld_rain) conditionParts.push(`in rain`);
            if (details.turn_upside_down) conditionParts.push(`Turn console upside-down`);
            if (trigger === 'trade') conditionParts.unshift('Trade');

            if (conditionParts.length === 0) {
                 return trigger.charAt(0).toUpperCase() + trigger.slice(1);
            }
            
            return conditionParts.join(', ');
        };

        const createPokemonNode = (pokemonData) => {
            if (!pokemonData) return '';
            return `<div class="evolution-pokemon text-center transition-transform hover:scale-110" data-pokemon-name="${pokemonData.name}">
                        <div class="w-24 h-24 bg-black bg-opacity-20 rounded-full mx-auto flex items-center justify-center p-1">
                            <img src="${pokemonData.sprites.other['official-artwork'].front_default || pokemonData.sprites.front_default}" alt="${pokemonData.name}" class="w-full h-full object-contain">
                        </div>
                        <p class="font-semibold capitalize mt-2 text-white">${pokemonData.name}</p>
                    </div>`;
        };
        
        const parseEvolutionChainRecursive = async (chain) => {
            const basePokemon = await getPokemonData(chain.species.name);
            let html = createPokemonNode(basePokemon);

            if (chain.evolves_to.length > 0) {
                const evolutionPaths = await Promise.all(chain.evolves_to.map(async (evo) => {
                    const details = formatEvolutionDetails(evo.evolution_details[0]);
                    const nextPokemonHtml = await parseEvolutionChainRecursive(evo);
                    return `<div class="flex flex-col items-center text-center">
                                <div class="text-2xl font-bold text-gray-500 my-2">&darr;</div>
                                <div class="text-xs text-amber-400 font-semibold mb-2 h-6 capitalize">${details}</div>
                                ${nextPokemonHtml}
                            </div>`;
                }));

                html += `<div class="flex flex-row flex-wrap justify-center items-start gap-x-8 gap-y-4 mt-2">${evolutionPaths.join('')}</div>`;
            }
            return html;
        };

        const displayEvolutionChain = async (evolutionData) => {
            if (!evolutionData || !evolutionData.chain) return '';
            const evolutionHtml = await parseEvolutionChainRecursive(evolutionData.chain);
            return `<div class="mt-6 pt-4 border-t-2 border-gray-700">
                        <h3 class="text-xl font-bold text-center mb-4 text-white">Evolution Line</h3>
                        <div class="flex flex-col items-center gap-4">
                            ${evolutionHtml}
                        </div>
                    </div>`;
        };

        const getGameAppearancesHTML = (gameIndices, pokemonId) => {
            const appearances = {};
            for (const game of gameIndices) {
                const detail = versionDetails[game.version.name];
                if (detail) {
                    const key = detail.series;
                    if (!appearances[key]) {
                        appearances[key] = { console: detail.console, series: detail.series };
                    }
                }
            }

            // Fallback for Gen 8 Pokémon if game_indices is empty
            if (Object.keys(appearances).length === 0 && pokemonId >= 810 && pokemonId <= 905) {
                const key = 'Sword/Shield (+DLC)';
                appearances[key] = { console: 'Nintendo Switch', series: key };
            }

            // Fallback for Gen 9 Pokémon if game_indices is empty
            if (Object.keys(appearances).length === 0 && pokemonId >= 906 && pokemonId <= 1025) {
                const key = 'Scarlet/Violet (+DLC)';
                appearances[key] = { console: 'Nintendo Switch', series: key };
            }

            if (Object.keys(appearances).length === 0) return '';

            const appearancesHTML = Object.values(appearances).map(group =>
                `<div class="text-sm"><span class="font-bold">${group.series}</span> <span class="text-gray-400">(${group.console})</span></div>`
            ).join('');

            return `<div class="mt-6">
                        <h4 class="font-bold text-md text-gray-300 border-b border-gray-700 pb-1 mb-2">Game Appearances</h4>
                        <div class="grid grid-cols-1 sm:grid-cols-2 gap-x-4 gap-y-1">
                            ${appearancesHTML}
                        </div>
                    </div>`;
        };

        const getPokemonEffectivenessHTML = async (pokemonTypes) => {
            const effectiveness = {};
            allPokemonTypes.forEach(t => effectiveness[t] = 1);

            for (const typeName of pokemonTypes) {
                const relations = await getTypeData(typeName);
                if (relations) {
                    relations.double_damage_from.forEach(t => effectiveness[t.name] *= 2);
                    relations.half_damage_from.forEach(t => effectiveness[t.name] *= 0.5);
                    relations.no_damage_from.forEach(t => effectiveness[t.name] *= 0);
                }
            }

            const matchups = { 4: [], 2: [], 0.5: [], 0.25: [], 0: [] };
            for (const typeName in effectiveness) {
                if (effectiveness[typeName] !== 1) {
                    matchups[effectiveness[typeName]].push(typeName);
                }
            }

            const hasMatchups = Object.values(matchups).some(arr => arr.length > 0);
            if (!hasMatchups) return '';

            let resultsHTML = `<div class="mt-6 pt-4 border-t-2 border-gray-700"><h3 class="text-xl font-bold text-center mb-4 text-white">Type Matchups</h3><div class="space-y-4">`;
            if (matchups[4].length > 0) resultsHTML += createMatchupSection('Weak To (4x)', matchups[4], 'bg-red-600');
            if (matchups[2].length > 0) resultsHTML += createMatchupSection('Weak To (2x)', matchups[2], 'bg-red-500');
            if (matchups[0.5].length > 0) resultsHTML += createMatchupSection('Resists (0.5x)', matchups[0.5], 'bg-green-500');
            if (matchups[0.25].length > 0) resultsHTML += createMatchupSection('Resists (0.25x)', matchups[0.25], 'bg-green-600');
            if (matchups[0].length > 0) resultsHTML += createMatchupSection('Immune To (0x)', matchups[0], 'bg-gray-500');
            resultsHTML += `</div></div>`;
            return resultsHTML;
        };

        const displayPokemon = async (data) => {
            if (!data) return;
            const types = data.types.map(typeInfo => `<span class="type-badge type-${typeInfo.type.name}">${typeInfo.type.name}</span>`).join(' ');
            const pokemonTypeNames = data.types.map(typeInfo => typeInfo.type.name);
            const gameAppearancesHTML = getGameAppearancesHTML(data.game_indices, data.id);
            const effectivenessHTML = await getPokemonEffectivenessHTML(pokemonTypeNames);
            const evolutionHTML = await displayEvolutionChain(await getEvolutionChain(data.species.url));
            const pokemonHTML = `<div class="p-4 sm:p-6 bg-black bg-opacity-20 rounded-lg"><div class="grid grid-cols-1 md:grid-cols-2 gap-6"><div class="flex flex-col items-center justify-center bg-black bg-opacity-20 rounded-lg p-4"><img class="max-h-60" src="${data.sprites.other['official-artwork'].front_default || data.sprites.front_default}" alt="${data.name}"></div><div class="text-white"><div class="flex justify-between items-baseline"><h2 class="text-4xl font-bold capitalize">${data.name}</h2><span class="font-bold text-2xl text-gray-400">#${String(data.id).padStart(4, '0')}</span></div><div class="mt-4 flex gap-2">${types}</div>${gameAppearancesHTML}<div class="mt-6"><h3 class="text-lg font-bold mb-2 border-b-2 border-gray-700 pb-1">Base Stats</h3><div class="grid grid-cols-2 gap-x-4 gap-y-2 text-sm">${data.stats.map(stat => `<div class="flex justify-between"><span class="font-semibold capitalize text-gray-300">${stat.stat.name.replace('-', ' ')}</span><span class="font-bold">${stat.base_stat}</span></div>`).join('')}</div></div></div></div>${effectivenessHTML}${evolutionHTML}</div>`;
            pokedexDisplay.innerHTML = pokemonHTML;
        };

        const displayError = (message) => {
            pokedexDisplay.innerHTML = `<div class="text-center text-red-400 font-bold p-8"><p class="text-2xl">Error!</p><p class="mt-2 text-lg">${message}</p></div>`;
        };

        const handleSearch = async () => {
            const searchTerm = searchInput.value.trim();
            if (searchTerm) {
                suggestionsContainer.classList.add('hidden');
                pokedexDisplay.innerHTML = '<div class="text-center p-8 text-gray-400">Loading...</div>';
                const pokemonData = await getPokemonData(searchTerm);
                if (pokemonData) displayPokemon(pokemonData);
            }
        };

        const displaySuggestions = (suggestions) => {
            if (suggestions.length === 0) {
                suggestionsContainer.classList.add('hidden');
                return;
            }
            suggestionsContainer.innerHTML = suggestions.map(name => `<div class="suggestion-item capitalize">${name}</div>`).join('');
            suggestionsContainer.classList.remove('hidden');
        };

        // --- TYPE CHART FUNCTIONS ---
        const calculateEffectiveness = async () => {
            if (selectedTypes.length === 0) {
                typeResultsDisplay.innerHTML = '<p class="text-center text-gray-400">Select a type to see its effectiveness.</p>';
                return;
            }

            typeResultsDisplay.innerHTML = '<div class="text-center p-8 text-gray-400">Calculating...</div>';

            const effectiveness = {};
            allPokemonTypes.forEach(t => effectiveness[t] = 1);

            for (const typeName of selectedTypes) {
                const relations = await getTypeData(typeName);
                if (relations) {
                    relations.double_damage_from.forEach(t => effectiveness[t.name] *= 2);
                    relations.half_damage_from.forEach(t => effectiveness[t.name] *= 0.5);
                    relations.no_damage_from.forEach(t => effectiveness[t.name] *= 0);
                }
            }
            
            const matchups = { 4: [], 2: [], 1: [], 0.5: [], 0.25: [], 0: [] };
            for (const typeName in effectiveness) {
                matchups[effectiveness[typeName]].push(typeName);
            }

            let resultsHTML = `<div class="space-y-4">`;
            if (matchups[4].length > 0) resultsHTML += createMatchupSection('Weak To (4x)', matchups[4], 'bg-red-600');
            if (matchups[2].length > 0) resultsHTML += createMatchupSection('Weak To (2x)', matchups[2], 'bg-red-500');
            if (matchups[0.5].length > 0) resultsHTML += createMatchupSection('Resists (0.5x)', matchups[0.5], 'bg-green-500');
            if (matchups[0.25].length > 0) resultsHTML += createMatchupSection('Resists (0.25x)', matchups[0.25], 'bg-green-600');
            if (matchups[0].length > 0) resultsHTML += createMatchupSection('Immune To (0x)', matchups[0], 'bg-gray-500');
            resultsHTML += `</div>`;
            
            typeResultsDisplay.innerHTML = resultsHTML;
        };
        
        const createMatchupSection = (title, types, bgColor) => {
            return `
                <div class="p-4 rounded-lg bg-black bg-opacity-20">
                    <h3 class="font-bold text-lg ${bgColor.replace('bg-', 'text-').slice(0, -4)}">${title}</h3>
                    <div class="flex flex-wrap gap-2 mt-2">
                        ${types.map(t => `<span class="type-badge type-${t}">${t}</span>`).join('')}
                    </div>
                </div>
            `;
        };
        
        const handleTypeClick = (typeName, element) => {
            const index = selectedTypes.indexOf(typeName);
            if (index > -1) {
                selectedTypes.splice(index, 1);
                element.classList.remove('selected');
            } else {
                if (selectedTypes.length < 2) {
                    selectedTypes.push(typeName);
                    element.classList.add('selected');
                }
            }
            document.querySelectorAll('.type-badge.selectable').forEach(btn => {
                if (selectedTypes.includes(btn.dataset.type)) {
                    btn.classList.add('selected');
                } else {
                    btn.classList.remove('selected');
                }
            });
            calculateEffectiveness();
        };

        const renderTypeGrid = () => {
            typeSelectionGrid.innerHTML = allPokemonTypes.map(type =>
                `<button data-type="${type}" class="type-badge selectable type-${type}">${type}</button>`
            ).join('');
            typeSelectionGrid.querySelectorAll('.type-badge').forEach(button => {
                button.addEventListener('click', () => handleTypeClick(button.dataset.type, button));
            });
        };


        // --- INITIALIZATION & EVENT LISTENERS ---
        const toggleMode = (mode) => {
            currentMode = mode;
            if (mode === 'pokedex') {
                modePokedexBtn.classList.add('active');
                modeTypeChartBtn.classList.remove('active');
                pokedexView.classList.remove('hidden');
                typeChartView.classList.add('hidden');
            } else {
                modePokedexBtn.classList.remove('active');
                modeTypeChartBtn.classList.add('active');
                pokedexView.classList.add('hidden');
                typeChartView.classList.remove('hidden');
                if (typeResultsDisplay.innerHTML === '') {
                     calculateEffectiveness();
                }
            }
        };

        modePokedexBtn.addEventListener('click', () => toggleMode('pokedex'));
        modeTypeChartBtn.addEventListener('click', () => toggleMode('typechart'));
        searchButton.addEventListener('click', handleSearch);
        searchInput.addEventListener('keypress', (e) => e.key === 'Enter' && handleSearch());

        searchInput.addEventListener('input', () => {
            const query = searchInput.value.toLowerCase();
            if (query.length === 0) {
                suggestionsContainer.classList.add('hidden');
                return;
            }
            const filtered = allPokemonNames.filter(name => name.includes(query)).slice(0, 5);
            displaySuggestions(filtered);
        });

        suggestionsContainer.addEventListener('click', (e) => {
            if (e.target.classList.contains('suggestion-item')) {
                searchInput.value = e.target.textContent;
                handleSearch();
            }
        });

        pokedexDisplay.addEventListener('click', (e) => {
            const evolutionPokemon = e.target.closest('.evolution-pokemon');
            if (evolutionPokemon) {
                const pokemonName = evolutionPokemon.dataset.pokemonName;
                if (pokemonName) {
                    searchInput.value = pokemonName;
                    handleSearch();
                }
            }
        });

        document.addEventListener('click', (e) => {
            if (!suggestionsContainer.contains(e.target) && e.target !== searchInput) {
                suggestionsContainer.classList.add('hidden');
            }
        });
        
        // Initial data fetch
        fetchAllPokemonNames();
        renderTypeGrid();
    </script>
</body>
</html>
